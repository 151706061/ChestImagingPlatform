// This file was automatically generated by:
//  /net/th914_nas.bwh.harvard.edu/mnt/array1/share/Software/Slicer/Slicer4-SuperBuild-Release/SlicerExecutionModel-build/GenerateCLP/bin/GenerateCLP --InputXML /projects/lmi/people/rharmo/projects/ChestImagingPlatformPrivate/CommandLineTools/GenerateAtlasConvexHull/GenerateAtlasConvexHull.xml --OutputCxx /projects/lmi/people/rharmo/projects/ChestImagingPlatformPrivate/CommandLineTools/GenerateAtlasConvexHull/GenerateAtlasConvexHullCLP.h
//
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>
#include <map>

#include <sstream>

#include "tclap/CmdLine.h"
#include "ModuleProcessInformation.h"

#ifdef WIN32
#define Module_EXPORT __declspec(dllexport)
#else
#define Module_EXPORT 
#endif

#if defined(main) && !defined(REGISTER_TEST)
// If main defined as a preprocessor symbol, redefine it to the expected entry point.
#undef main
#define main ModuleEntryPoint

extern "C" {
  Module_EXPORT char *GetXMLModuleDescription();
  Module_EXPORT int ModuleEntryPoint(int, char*[]);
}
#endif

extern "C" {
Module_EXPORT char XMLModuleDescription[] = 
"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
"<executable>\n"
"  <category>Examples</category>\n"
"  <title>GenerateAtlasConvexHull</title>\n"
"  <description><![CDATA[his program reads atlas lung images and generates a convex hull image corresponding to them. It is assumed that the atlas exists as two separate atlases: one for the left lung and one for the right. It is also assumed that the the maximum value in each corresponds to a probability of 1 and the value 0 corresponds to a probability of 0. The algorithm proceeds by reading in the left atlas and thresholding according to a specified probability threhold (a float-valued quantity ranging from 0 to 1). The right atlas is read in and similarly thresholded. The union of the two images is created, and the resulting image is downsampled for faster processing. After downsampling, the convex hull is created. The convex hull is represented as a binary image (0 = background, 1 = foreground). The convex hull is upsampled so that it has the same extent as the original image, and it is then written to file.]]></description>\n"
"  <version>0.0.1</version>\n"
"  <documentation-url>http://www.slicer.org/slicerWiki/index.php/Documentation/4.2/Modules/ResampleLabelMap</documentation-url>\n"
"  <license>Slicer</license>\n"
"  <contributor> Applied Chest Imaging Laboratory, Brigham and women's hospital</contributor>\n"
"  <acknowledgements>This work was partially funded ...</acknowledgements>\n"
"\n"
"  <parameters>\n"
"    <string>\n"
"      <name>leftAtlasFileName</name>\n"
"      <label>Left Atlas Filename</label>\n"
"      <channel>input</channel>\n"
"      <flag>l</flag>\n"
"      <longflag>--leftAtlas</longflag>\n"
"      <description><![CDATA[Left lung atlas file name]]></description>\n"
"      <default>q</default>\n"
"    </string>   \n"
"    <string>\n"
"      <name>rightAtlasFileName</name>\n"
"      <label>right Atlas FileName</label>\n"
"      <channel>input</channel>\n"
"      <flag>r</flag>\n"
"      <longflag>--rightAtlas</longflag>\n"
"      <description><![CDATA[Right lung atlas file name]]></description>\n"
"      <default>q</default>\n"
"    </string>\n"
"    <string>\n"
"      <name>outputFileName</name>\n"
"      <label>output Filename</label>\n"
"      <channel>input</channel>\n"
"      <flag>o</flag>\n"
"      <longflag>--output</longflag>\n"
"      <description><![CDATA[Output convex hull file name]]></description>\n"
"      <default>q</default>\n"
"    </string>   \n"
"    <integer>\n"
"      <name>numRotations</name>\n"
"      <label>number of Rotations</label>\n"
"      <channel>input</channel>\n"
"      <flag>n</flag>\n"
"      <longflag>--numRotations</longflag>\n"
"      <description><![CDATA[Number of rotations. This quanity relates to the accuracy of the final convex hull. Increasing the number of rotations increases accuracy. If this quantity changes, so should the resolution degrees parameter (specified by the -dr flag). E.g. if number of rotations increases by a factor of two, degrees resolution should decrease by a factor of two.]]></description>\n"
"      <default>1</default>\n"
"    </integer>   \n"
"\n"
"\n"
"    <float>\n"
"      <name>degreesResolution</name>\n"
"      <label>degrees of Resolution</label>\n"
"      <channel>input</channel>\n"
"      <flag>d</flag>\n"
"      <longflag>--degrees</longflag>\n"
"      <description><![CDATA[Degrees resolution. This quanity relates to the accuracy of the final convex hull. Decreasing the degrees resolution increases accuracy. If this quantity changes, so should the number of rotations parameter (specified by the -nr flag). E.g. if number of rotations increases by a factor of two, degrees resolution should decrease by a factor of two]]></description>\n"
"      <default>45</default>\n"
"    </float>  \n"
"    <float>\n"
"      <name>downsampleFactor</name>\n"
"      <label>downsample Factor</label>\n"
"      <channel>input</channel>\n"
"      <flag>s</flag>\n"
"      <longflag>--sample</longflag>\n"
"      <description><![CDATA[Down sample factor]]></description>\n"
"      <default>1</default>\n"
"    </float>  \n"
"    <float>\n"
"      <name>probabilityThreshold</name>\n"
"      <label>probability Threshold</label>\n"
"      <channel>input</channel>\n"
"      <flag>p</flag>\n"
"      <longflag>--probability</longflag>\n"
"      <description><![CDATA[Probability threshold in the interval [0,1]. This parameter controls the level at which the atlas is thresholded prior to convex hull creation]]></description>\n"
"      <default>0.5</default>\n"
"    </float>  \n"
"  </parameters>\n"
"</executable>\n"
;

}

void
splitString (const std::string &text,
             const std::string &separators,
             std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  std::string::size_type start = text.find_first_not_of(separators);
  while (start < n)
    {
    std::string::size_type stop = text.find_first_of(separators, start);
    if (stop > n) stop = n;
    words.push_back(text.substr(start, stop - start));
    start = text.find_first_not_of(separators, stop+1);
    }
}

void
splitFilenames (const std::string &text,
                std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  bool quoted;
  std::string comma(",");
  std::string quote("\"");
  std::string::size_type start = text.find_first_not_of(comma);
  while (start < n)
    {
    quoted = false;
    std::string::size_type startq = text.find_first_of(quote, start);
    std::string::size_type stopq = text.find_first_of(quote, startq+1);
    std::string::size_type stop = text.find_first_of(comma, start);
    if (stop > n) stop = n;
    if (startq != std::string::npos && stopq != std::string::npos)
      {
      while (startq < stop && stop < stopq && stop != n)
         {
         quoted = true;
         stop = text.find_first_of(comma, stop+1);
         if (stop > n) stop = n;
         }
      }
    if (!quoted)
      {
      words.push_back(text.substr(start, stop - start));
      }
    else
      {
      words.push_back(text.substr(start+1, stop - start-2));
      }
    start = text.find_first_not_of(comma, stop+1);
    }
}

char *GetXMLModuleDescription()
{
   return XMLModuleDescription;
}

#define GENERATE_LOGO
#define GENERATE_XML \
  if (argc >= 2 && (strcmp(argv[1],"--xml") == 0)) \
    { \
    std::cout << GetXMLModuleDescription(); \
    return EXIT_SUCCESS; \
    }
#define GENERATE_TCLAP \
    std::string leftAtlasFileName = "q"; \
    std::string rightAtlasFileName = "q"; \
    std::string outputFileName = "q"; \
    int numRotations = 1; \
    float degreesResolution = 45; \
    float downsampleFactor = 1; \
    float probabilityThreshold = 0.5; \
    bool echoSwitch = false; \
    bool xmlSwitch = false; \
    std::string processInformationAddressString = "0"; \
    std::string returnParameterFile; \
    std::string fullDescription("Description: "); \
    fullDescription += "his program reads atlas lung images and generates a convex hull image corresponding to them. It is assumed that the atlas exists as two separate atlases: one for the left lung and one for the right. It is also assumed that the the maximum value in each corresponds to a probability of 1 and the value 0 corresponds to a probability of 0. The algorithm proceeds by reading in the left atlas and thresholding according to a specified probability threhold (a float-valued quantity ranging from 0 to 1). The right atlas is read in and similarly thresholded. The union of the two images is created, and the resulting image is downsampled for faster processing. After downsampling, the convex hull is created. The convex hull is represented as a binary image (0 = background, 1 = foreground). The convex hull is upsampled so that it has the same extent as the original image, and it is then written to file."; \
    if (!std::string("Applied Chest Imaging Laboratory, Brigham and women's hospital").empty()) \
      { \
      fullDescription += "\nAuthor(s): Applied Chest Imaging Laboratory, Brigham and women's hospital"; \
      } \
    if (!std::string("This work was partially funded ...").empty()) \
      { \
      fullDescription += "\nAcknowledgements: This work was partially funded ..."; \
      } \
    TCLAP::CmdLine commandLine (fullDescription, \
       ' ', \
      "0.0.1" ); \
 \
      std::ostringstream msg; \
    msg.str("");msg << "Left lung atlas file name (default: " << leftAtlasFileName << ")"; \
    TCLAP::ValueArg<std::string > leftAtlasFileNameArg("l", "leftAtlas", msg.str(), 0, leftAtlasFileName, "std::string", commandLine); \
 \
    msg.str("");msg << "Right lung atlas file name (default: " << rightAtlasFileName << ")"; \
    TCLAP::ValueArg<std::string > rightAtlasFileNameArg("r", "rightAtlas", msg.str(), 0, rightAtlasFileName, "std::string", commandLine); \
 \
    msg.str("");msg << "Output convex hull file name (default: " << outputFileName << ")"; \
    TCLAP::ValueArg<std::string > outputFileNameArg("o", "output", msg.str(), 0, outputFileName, "std::string", commandLine); \
 \
    msg.str("");msg << "Number of rotations. This quanity relates to the accuracy of the final convex hull. Increasing the number of rotations increases accuracy. If this quantity changes, so should the resolution degrees parameter (specified by the -dr flag). E.g. if number of rotations increases by a factor of two, degrees resolution should decrease by a factor of two. (default: " << numRotations << ")"; \
    TCLAP::ValueArg<int > numRotationsArg("n", "numRotations", msg.str(), 0, numRotations, "int", commandLine); \
 \
    msg.str("");msg << "Degrees resolution. This quanity relates to the accuracy of the final convex hull. Decreasing the degrees resolution increases accuracy. If this quantity changes, so should the number of rotations parameter (specified by the -nr flag). E.g. if number of rotations increases by a factor of two, degrees resolution should decrease by a factor of two (default: " << degreesResolution << ")"; \
    TCLAP::ValueArg<float > degreesResolutionArg("d", "degrees", msg.str(), 0, degreesResolution, "float", commandLine); \
 \
    msg.str("");msg << "Down sample factor (default: " << downsampleFactor << ")"; \
    TCLAP::ValueArg<float > downsampleFactorArg("s", "sample", msg.str(), 0, downsampleFactor, "float", commandLine); \
 \
    msg.str("");msg << "Probability threshold in the interval [0,1]. This parameter controls the level at which the atlas is thresholded prior to convex hull creation (default: " << probabilityThreshold << ")"; \
    TCLAP::ValueArg<float > probabilityThresholdArg("p", "probability", msg.str(), 0, probabilityThreshold, "float", commandLine); \
 \
    msg.str("");msg << "Echo the command line arguments (default: " << echoSwitch << ")"; \
    TCLAP::SwitchArg echoSwitchArg("", "echo", msg.str(), commandLine, echoSwitch); \
 \
    msg.str("");msg << "Produce xml description of command line arguments (default: " << xmlSwitch << ")"; \
    TCLAP::SwitchArg xmlSwitchArg("", "xml", msg.str(), commandLine, xmlSwitch); \
 \
    msg.str("");msg << "Address of a structure to store process information (progress, abort, etc.). (default: " << processInformationAddressString << ")"; \
    TCLAP::ValueArg<std::string > processInformationAddressStringArg("", "processinformationaddress", msg.str(), 0, processInformationAddressString, "std::string", commandLine); \
 \
    msg.str("");msg << "Filename in which to write simple return parameters (int, float, int-vector, etc.) as opposed to bulk return parameters (image, geometry, transform, measurement, table).";    TCLAP::ValueArg<std::string > returnParameterFileArg("", "returnparameterfile", msg.str(), 0, returnParameterFile, "std::string", commandLine); \
 \
try \
  { \
    /* Build a map of flag aliases to the true flag */ \
    std::map<std::string,std::string> flagAliasMap; \
    std::map<std::string,std::string> deprecatedFlagAliasMap; \
    std::map<std::string,std::string> longFlagAliasMap; \
    std::map<std::string,std::string> deprecatedLongFlagAliasMap; \
    /* Remap flag aliases to the true flag */ \
    std::vector<std::string> targs; \
    std::map<std::string,std::string>::iterator ait; \
    std::map<std::string,std::string>::iterator dait; \
    size_t ac; \
    for (ac=0; ac < static_cast<size_t>(argc); ++ac)  \
       {  \
       if (strlen(argv[ac]) == 2 && argv[ac][0]=='-') \
         { \
         /* short flag case */ \
         std::string tflag(argv[ac], 1, strlen(argv[ac])-1); \
         ait = flagAliasMap.find(tflag); \
         dait = deprecatedFlagAliasMap.find(tflag); \
         if (ait != flagAliasMap.end() || dait != deprecatedFlagAliasMap.end()) \
           { \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             targs.push_back("-" + (*ait).second); \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << argv[ac] << "\" is deprecated. Please use flag \"-" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             targs.push_back("-" + (*dait).second); \
             } \
           } \
         else \
           { \
           targs.push_back(argv[ac]); \
           } \
         } \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]=='-') \
         { \
         /* long flag case */ \
         std::string tflag(argv[ac], 2, strlen(argv[ac])-2); \
         ait = longFlagAliasMap.find(tflag); \
         dait = deprecatedLongFlagAliasMap.find(tflag); \
         if (ait != longFlagAliasMap.end() || dait != deprecatedLongFlagAliasMap.end()) \
           { \
           if (ait != longFlagAliasMap.end()) \
             { \
             /* remap the flag */ \
             targs.push_back("--" + (*ait).second); \
             } \
           else if (dait != deprecatedLongFlagAliasMap.end()) \
             { \
             std::cout << "Long flag \"" << argv[ac] << "\" is deprecated. Please use long flag \"--" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             targs.push_back("--" + (*dait).second); \
             } \
           } \
         else \
           { \
           targs.push_back(argv[ac]); \
           } \
         } \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]!='-') \
         { \
         /* short flag case where multiple flags are given at once ala */ \
         /* "ls -ltr" */ \
         std::string tflag(argv[ac], 1, strlen(argv[ac])-1); \
         std::string rflag("-"); \
         for (std::string::size_type fi=0; fi < tflag.size(); ++fi) \
           { \
           std::string tf(tflag, fi, 1); \
           ait = flagAliasMap.find(tf); \
           dait = deprecatedFlagAliasMap.find(tf); \
           if (ait != flagAliasMap.end() || dait != deprecatedFlagAliasMap.end()) \
             { \
             if (ait != flagAliasMap.end()) \
               { \
               /* remap the flag */ \
               rflag += (*ait).second; \
               } \
             else if (dait != deprecatedFlagAliasMap.end()) \
               { \
               std::cout << "Flag \"-" << tf << "\" is deprecated. Please use flag \"-" << (*dait).second << "\" instead. " << std::endl; \
               /* remap the flag */ \
               rflag += (*dait).second; \
               } \
             } \
           else \
             { \
             rflag += tf; \
             } \
           } \
         targs.push_back(rflag); \
         } \
       else \
         { \
         /* skip the argument without remapping (this is the case for any */ \
         /* arguments for flags */ \
         targs.push_back(argv[ac]); \
         } \
       } \
 \
   /* Remap args to a structure that CmdLine::parse() can understand*/ \
   std::vector<char*> vargs; \
   for (ac = 0; ac < targs.size(); ++ac) \
     {  \
     vargs.push_back(const_cast<char *>(targs[ac].c_str())); \
     } \
    commandLine.parse ( vargs.size(), (char**) &(vargs[0]) ); \
    leftAtlasFileName = leftAtlasFileNameArg.getValue(); \
    rightAtlasFileName = rightAtlasFileNameArg.getValue(); \
    outputFileName = outputFileNameArg.getValue(); \
    numRotations = numRotationsArg.getValue(); \
    degreesResolution = degreesResolutionArg.getValue(); \
    downsampleFactor = downsampleFactorArg.getValue(); \
    probabilityThreshold = probabilityThresholdArg.getValue(); \
    echoSwitch = echoSwitchArg.getValue(); \
    xmlSwitch = xmlSwitchArg.getValue(); \
    processInformationAddressString = processInformationAddressStringArg.getValue(); \
    returnParameterFile = returnParameterFileArg.getValue(); \
  } \
catch ( TCLAP::ArgException e ) \
  { \
  std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl; \
  return ( EXIT_FAILURE ); \
  }
#define GENERATE_ECHOARGS \
if (echoSwitch) \
{ \
std::cout << "Command Line Arguments" << std::endl; \
std::cout << "    leftAtlasFileName: " << leftAtlasFileName << std::endl; \
std::cout << "    rightAtlasFileName: " << rightAtlasFileName << std::endl; \
std::cout << "    outputFileName: " << outputFileName << std::endl; \
std::cout << "    numRotations: " << numRotations << std::endl; \
std::cout << "    degreesResolution: " << degreesResolution << std::endl; \
std::cout << "    downsampleFactor: " << downsampleFactor << std::endl; \
std::cout << "    probabilityThreshold: " << probabilityThreshold << std::endl; \
std::cout << "    echoSwitch: " << echoSwitch << std::endl; \
std::cout << "    xmlSwitch: " << xmlSwitch << std::endl; \
std::cout << "    processInformationAddressString: " << processInformationAddressString << std::endl; \
std::cout << "    returnParameterFile: " << returnParameterFile << std::endl; \
}
#define GENERATE_ProcessInformationAddressDecoding \
ModuleProcessInformation *CLPProcessInformation = 0; \
if (processInformationAddressString != "") \
{ \
sscanf(processInformationAddressString.c_str(), "%p", &CLPProcessInformation); \
}
#define PARSE_ARGS GENERATE_LOGO;GENERATE_XML;GENERATE_TCLAP;GENERATE_ECHOARGS;GENERATE_ProcessInformationAddressDecoding;
