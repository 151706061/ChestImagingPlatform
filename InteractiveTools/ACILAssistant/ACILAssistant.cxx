// generated by Fast Light User Interface Designer (fluid) version 1.0107

#include "ACILAssistant.h"
#include <fstream>
#include <sys/stat.h>
#include "PaintBrushAndEraserGUI.h"
#include "ACILAssistantBase.h"
#include "itkImageFileReader.h"
#include "itkImageRegionIteratorWithIndex.h"
#include "itkImageSeriesReader.h"
#include "itkGDCMImageIO.h"
#include "itkGDCMSeriesFileNames.h"
#include "itkColorTable.h"
#include "itkImageFileWriter.h"
#include "cipConventions.h"
#include "itkImage.h"
#include <FL/Fl_File_Chooser.H>
#include <iostream>
using namespace std;
static std::vector< std::string > sessionGrayscaleFileNameVec;
static std::vector< std::string > sessionInLabelMapFileNameVec;
static std::vector< std::string > sessionOutLabelMapFileNameVec;
static std::vector< std::string > sessionRegionTypeIndicesFileNameVec;
static bool grayscaleImageRead = false;
static PaintBrushAndEraserGUI* paintBrushAndEraserInput;
static bool labelMapImageRead = false;
static ACILAssistantBase* assistantInstance;

Fl_Double_Window *acilAssistantMainWindow=(Fl_Double_Window *)0;

Fl_Menu_Item menu_Menu[] = {
 {"File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Grayscale Image", 0,  (Fl_Callback*)GrayscaleImage_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Dicom Directory", 0,  (Fl_Callback*)DicomDirectory_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Label Map Image", 0,  (Fl_Callback*)LabelMapImage_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Session File", 0,  (Fl_Callback*)SessionFile_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Save Session Data", 0,  (Fl_Callback*)SaveSessionDataMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save Label Map Image", 0,  (Fl_Callback*)SaveLabelMapImageMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save Region Type Points", 0,  (Fl_Callback*)SaveRegionTypePointsMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Quit", 0,  (Fl_Callback*)Quit_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},

 {"Tools", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Paint Brush And Eraser", 0,  (Fl_Callback*)paintBrushAndEraserMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},

 {"Segmentation", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Left Lung Right Lung", 0,  (Fl_Callback*)leftLungRightLungMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Lung Lobes", 0,  (Fl_Callback*)lungLobesMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},

 {"Window-Level", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Lung", 0,  (Fl_Callback*)lungMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Muscle", 0,  (Fl_Callback*)muscleMenu_CB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},

 {0,0,0,0,0,0,0,0,0}
};

GLSliceView< short, unsigned short > *sliceViewer=(GLSliceView< short, unsigned short > *)0;

Fl_Scrollbar *sliceSlider=(Fl_Scrollbar *)0;

Fl_Slider *opacitySlider=(Fl_Slider *)0;

int main(int argc, char **argv) {
  Fl_Double_Window* w;
  assistantInstance = new ACILAssistantBase();
  paintBrushAndEraserInput = new PaintBrushAndEraserGUI();
paintBrushAndEraserInput->SetUpdateViewerFunction( &UpdateViewer );
paintBrushAndEraserInput->SetPaintedIndices( assistantInstance->GetPaintedIndices() );
  { Fl_Double_Window* o = acilAssistantMainWindow = new Fl_Double_Window(640, 630, "ACIL Assistant");
    w = o;
    o->color((Fl_Color)185);
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 830, 20, "Menu Bar");
      o->menu(menu_Menu);
    }
    { GLSliceView< short, unsigned short >* o = sliceViewer = new GLSliceView< short, unsigned short >(0, 20, 620, 590, "label");
      o->box(FL_NO_BOX);
      o->color((Fl_Color)48);
      o->selection_color((Fl_Color)48);
      o->labeltype(FL_NORMAL_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor((Fl_Color)48);
      o->align(FL_ALIGN_CENTER);
      o->when(FL_WHEN_RELEASE);
      sliceViewer->clickSelectCallBack( clickSelect_CB );
    }
    { Fl_Scrollbar* o = sliceSlider = new Fl_Scrollbar(620, 20, 20, 610);
      o->callback((Fl_Callback*)sliceSlider_CB);
      sliceSlider->linesize(1);
    }
    { Fl_Slider* o = opacitySlider = new Fl_Slider(0, 610, 620, 20);
      o->type(1);
      o->value(1);
      o->callback((Fl_Callback*)opacitySlider_CB);
    }
    o->end();
    o->resizable(o);
  }
  Fl::scheme("plastic");
  w->show(argc, argv);
  return Fl::run();
}

void GrayscaleImage_CB( Fl_Widget*, void* ) {
  Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::SINGLE, "Open");	                
    chooser.show();
 
  typedef itk::Image< short, 3 >                      GrayscaleImageType;
  typedef itk::ImageFileReader< GrayscaleImageType >  ReaderType; 

  //-------
  // Block until user picks something
  //
  while(chooser.shown())
    {
    Fl::wait(); 
    }

  if ( chooser.value() == NULL )
    {   
    return; 
    }
  else
    {
    std::cout << "Reading grayscale image..." << std::endl;
    ReaderType::Pointer reader = ReaderType::New();
      reader->SetFileName( chooser.value() );
      try
      {
        reader->Update();
      }
      catch ( itk::ExceptionObject &excp )
      {
      	std::cerr << "Exception caught reading grayscale image:";
      	std::cerr << excp << std::endl;
      }
   
    ACILAssistantBase::GrayscaleImageType::SizeType     size;
    ACILAssistantBase::GrayscaleImageType::SpacingType  spacing;
    ACILAssistantBase::GrayscaleImageType::PointType    origin;
   
    size    = reader->GetOutput()->GetBufferedRegion().GetSize();
    spacing = reader->GetOutput()->GetSpacing();
    origin  = reader->GetOutput()->GetOrigin();
   
    assistantInstance->SetGrayscaleImage( reader->GetOutput() );	
    assistantInstance->InitializeLabelMapImage( size, spacing, origin );

    int numberOfSlices = reader->GetOutput()->GetBufferedRegion().GetSize()[2];
 
    sliceSlider->maximum( numberOfSlices-1 );

 
    //-------
    // Label the main window to indicate which image has been read
    //
    std::string dirAndFileNameString( chooser.value() );
    
    unsigned int slashLoc = -1;
    
    do
      {
        slashLoc = dirAndFileNameString.find( "/", slashLoc+1 );
      }
    while ( dirAndFileNameString.find( "/", slashLoc+1 ) != std::string::npos );
     
    acilAssistantMainWindow->label( dirAndFileNameString.substr( slashLoc+1, dirAndFileNameString.size()-slashLoc-1 ).c_str() );
    
    std::cout << "DONE." << std::endl;
    
    grayscaleImageRead = true;
    }

  InitializeViewer();
}

void UpdateViewer() {
  sliceViewer->OverlayOpacity( opacitySlider->value() );	
sliceViewer->update();
sliceViewer->redraw();
sliceViewer->show();
sliceViewer->flush();
}

void DicomDirectory_CB( Fl_Widget*, void* ) {
  Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::DIRECTORY, "Open");	                
    chooser.show();

typedef itk::Image< short, 3 >                        GrayscaleImageType;
typedef itk::GDCMImageIO                              ImageIOType;
typedef itk::GDCMSeriesFileNames                      NamesGeneratorType;
typedef itk::ImageSeriesReader< GrayscaleImageType >  SeriesReaderType;


//-------
// Block until user picks something
//
while(chooser.shown())
  {
  Fl::wait(); 
  }

if ( chooser.value() == NULL )
  {   
  return; 
  }
else
  {
  ImageIOType::Pointer gdcmImageIO = ImageIOType::New();
  
  NamesGeneratorType::Pointer namesGenerator = NamesGeneratorType::New();
    namesGenerator->SetInputDirectory( chooser.value() );

  const SeriesReaderType::FileNamesContainer & fileNames = namesGenerator->GetInputFileNames();

  std::cout << "Reading dicom directory..." << std::endl;
  SeriesReaderType::Pointer reader = SeriesReaderType::New();
    reader->SetFileNames( fileNames );
    reader->SetImageIO( gdcmImageIO );
  try
    {
    reader->Update();
    }
  catch ( itk::ExceptionObject &excp )
    {
    std::cerr << "Exception caught while reading dicom frame:";
    std::cerr << excp << std::endl;
    }    
    
    ACILAssistantBase::GrayscaleImageType::SizeType     size;
    ACILAssistantBase::GrayscaleImageType::SpacingType  spacing;
    ACILAssistantBase::GrayscaleImageType::PointType    origin;
   
    size    = reader->GetOutput()->GetBufferedRegion().GetSize();
    spacing = reader->GetOutput()->GetSpacing();
    origin  = reader->GetOutput()->GetOrigin();
   
    assistantInstance->SetGrayscaleImage( reader->GetOutput() );	
    assistantInstance->InitializeLabelMapImage( size, spacing, origin );

    int numberOfSlices = reader->GetOutput()->GetBufferedRegion().GetSize()[2];
 
    sliceSlider->maximum( numberOfSlices-1 );
    
    std::cout << "DONE." << std::endl;
    
    grayscaleImageRead = true;

  }

InitializeViewer();
}

void InitializeViewer() {
  ChestConventions conventions;

//unsigned short obliqueFissureLabel         = conventions.GetValueFromLungRegionAndType( UNDEFINEDREGION, OBLIQUEFISSURE );
//unsigned short horizontalFissureLabel      = conventions.GetValueFromLungRegionAndType( UNDEFINEDREGION, HORIZONTALFISSURE );
//unsigned short leftLungLabel               = conventions.GetValueFromLungRegionAndType( LEFTLUNG, UNDEFINEDTYPE );
//unsigned short rightLungLabel              = conventions.GetValueFromLungRegionAndType( RIGHTLUNG, UNDEFINEDTYPE );
//unsigned short leftObliqueFissureLabel     = conventions.GetValueFromLungRegionAndType( LEFTLUNG, OBLIQUEFISSURE );
//unsigned short rightObliqueFissureLabel    = conventions.GetValueFromLungRegionAndType( RIGHTLUNG, OBLIQUEFISSURE );
//unsigned short rightHorizontalFissureLabel = conventions.GetValueFromLungRegionAndType( RIGHTLUNG, HORIZONTALFISSURE );
//unsigned short rightSuperiorLobeLabel      = conventions.GetValueFromLungRegionAndType( RIGHTSUPERIORLOBE, UNDEFINEDTYPE );
//unsigned short rightMiddleLobeLabel        = conventions.GetValueFromLungRegionAndType( RIGHTMIDDLELOBE, UNDEFINEDTYPE );
//unsigned short rightInferiorLobeLabel      = conventions.GetValueFromLungRegionAndType( RIGHTINFERIORLOBE, UNDEFINEDTYPE );
//unsigned short leftSuperiorLobeLabel       = conventions.GetValueFromLungRegionAndType( LEFTSUPERIORLOBE, UNDEFINEDTYPE );
//unsigned short leftInteriorLobeLabel       = conventions.GetValueFromLungRegionAndType( LEFTINFERIORLOBE, UNDEFINEDTYPE );

//unsigned short airwayGeneration0Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION0 );
//unsigned short airwayGeneration1Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION1 );
//unsigned short airwayGeneration2Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION2 );
unsigned short airwayGeneration3Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION3 );
unsigned short airwayGeneration4Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION4 );
unsigned short airwayGeneration5Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION5 );
unsigned short airwayGeneration6Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION6 );
unsigned short airwayGeneration7Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION7 );
unsigned short airwayGeneration8Label  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, AIRWAYGENERATION8 );
unsigned short expiratoryMalaciaLabel  = conventions.GetValueFromChestRegionAndType( UNDEFINEDREGION, EXPIRATORYMALACIA );

typedef itk::ColorTable< float > ColorTableType;

ColorTableType::Pointer colorTable = ColorTableType::New();
colorTable->UseRandomColors( 50000 );


//colorTable->SetColor( obliqueFissureLabel-1,         0.0, 0.0, 0.5, "ObliqueFissure" );
//colorTable->SetColor( horizontalFissureLabel-1,      0.0, 0.0, 1.0, "HorizontalFissure" );
//colorTable->SetColor( leftLungLabel-1,               0.0, 1.0, 0.0, "LeftLung" );
//colorTable->SetColor( rightLungLabel-1,              0.0, 1.0, 1.0, "RightLung" );
//colorTable->SetColor( leftObliqueFissureLabel-1,     1.0, 0.0, 0.0, "LeftObliqueFissure" );
//colorTable->SetColor( rightObliqueFissureLabel-1,    1.0, 0.0, 1.0, "RightObliqueFissure" );
//colorTable->SetColor( rightHorizontalFissureLabel-1, 1.0, 1.0, 0.0, "RightHorizontalFissure" );
//colorTable->SetColor( rightSuperiorLobeLabel-1,      0.5, 0.5, 0.0, "RightSuperiorLobe" );
//colorTable->SetColor( rightMiddleLobeLabel-1,        0.0, 0.5, 0.5, "RightMiddleLobe" );
//colorTable->SetColor( rightInferiorLobeLabel-1,      0.0, 0.5, 0.0, "RightInferiorLobe" );
//colorTable->SetColor( leftSuperiorLobeLabel-1,       0.5, 0.0, 0.5, "LeftSuperiorLobe" );
//colorTable->SetColor( leftInteriorLobeLabel-1,       0.5, 0.0, 0.0, "LeftInteriorLobe" );
colorTable->SetColor( expiratoryMalaciaLabel-1,       0.0, 1.0, 0.0, "ExpiratoryMalacia" );

colorTable->SetColor( airwayGeneration3Label-1, 0.63, 0.13, 0.94, "AirwayGeneration3" );
colorTable->SetColor( airwayGeneration4Label-1, 0.0,  1.0,  0.0,  "AirwayGeneration4" );
colorTable->SetColor( airwayGeneration5Label-1, 1.0,  0.41, 0.71, "AirwayGeneration5" );
colorTable->SetColor( airwayGeneration6Label-1, 0.39, 0.58, 0.93, "AirwayGeneration6" );
colorTable->SetColor( airwayGeneration7Label-1, 1.0,  1.0,  0.0,  "AirwayGeneration7" );
colorTable->SetColor( airwayGeneration8Label-1, 1.0,  0.0,  0.0,  "AirwayGeneration8" );

sliceViewer->clear();
sliceViewer->SetInputImage( assistantInstance->GetGrayscaleImage() );
sliceViewer->SetInputOverlay( assistantInstance->GetLabelMapImage() );
sliceViewer->orientation( 2 );
sliceViewer->flipY( true );
sliceViewer->sliceNum( 0 );
sliceViewer->iwMax( -100 );
sliceViewer->iwMin( -1200 );
sliceViewer->SetOverlayColorIndex( 50000 );
sliceViewer->SetColorTable( colorTable );

paintBrushAndEraserInput->SetLabelMapImage( assistantInstance->GetLabelMapImage() );


UpdateViewer();
}

void sliceSlider_CB( Fl_Widget*, void* ) {
  sliceViewer->sliceNum( sliceSlider->value() );

UpdateViewer();
}

void LabelMapImage_CB( Fl_Widget*, void* ) {
  if ( !grayscaleImageRead )
{
  std::cerr << "Must first read a grayscale image!" << std::endl;
  
  return;
}


Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::SINGLE, "Open");	                
    chooser.show();
 
  typedef itk::Image< unsigned short, 3 >       LabelMapType;
  typedef itk::ImageFileReader< LabelMapType >  ReaderType; 

  //-------
  // Block until user picks something
  //
  while(chooser.shown())
    {
    Fl::wait(); 
    }

  if ( chooser.value() == NULL )
    {   
    return; 
    }
  else
    {
    std::cout << "Reading label map image..." << std::endl;
    ReaderType::Pointer reader = ReaderType::New();
      reader->SetFileName( chooser.value() );
      try
      {
        reader->Update();
      }
      catch ( itk::ExceptionObject &excp )
      {
      	std::cerr << "Exception caught reading grayscale image:";
      	std::cerr << excp << std::endl;
      }
   
    assistantInstance->SetLabelMapImage( reader->GetOutput() );	
    
    sliceViewer->SetInputOverlay( assistantInstance->GetLabelMapImage() );    
    
    labelMapImageRead = true;
        
    UpdateViewer();    
        
    std::cout << "DONE." << std::endl;
    }
}

void SessionFile_CB( Fl_Widget*, void* ) {
  typedef itk::Image< short, 3 >                      GrayscaleImageType;
typedef itk::ImageFileReader< GrayscaleImageType >  GrayscaleReaderType; 
typedef itk::Image< unsigned short, 3 >             LabelMapType;
typedef itk::ImageFileReader< LabelMapType >        LabelMapReaderType; 

Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::SINGLE, "Open");	                
    chooser.show();
 
  //-------
  // Block until user picks something
  //
  while(chooser.shown())
    {
    Fl::wait(); 
    }

  if ( chooser.value() == NULL )
    {   
    return; 
    }
  else
    {
    char firstLine[512];
    char secondLine[512];
    char thirdLine[512];
    char fourthLine[512];
    
    std::cout << "Reading session file..." << std::endl;
    
    std::ifstream sessionFile( chooser.value() );
    while ( !sessionFile.eof() )
      {
      sessionFile.getline( firstLine, 512 );
      std::string grayscaleFileName( firstLine );   
      
      sessionFile.getline( secondLine, 512 ); 
      std::string inLabelMapFileName( secondLine );        
      
      sessionFile.getline( thirdLine, 512 );
      std::string outLabelMapFileName( thirdLine );   
      
      sessionFile.getline( fourthLine, 512 );  
      std::string regionTypeIndicesFileName( fourthLine );   
        
      struct stat stFileInfo;             

      //
      // Only add to session file data if the output mask and
      // region-type indices file name do not already exist
      //
      if ( stat( firstLine, &stFileInfo ) == 0 &&
           (stat( secondLine, &stFileInfo) == 0  || inLabelMapFileName.compare("NA") == 0) &&
           (stat( thirdLine, &stFileInfo ) != 0  || outLabelMapFileName.compare("NA") == 0) &&
           (stat( fourthLine, &stFileInfo ) != 0 || regionTypeIndicesFileName.compare("NA") == 0))
        {          
          sessionGrayscaleFileNameVec.push_back( grayscaleFileName );              
          sessionInLabelMapFileNameVec.push_back( inLabelMapFileName );                  
          sessionOutLabelMapFileNameVec.push_back( outLabelMapFileName );  
          sessionRegionTypeIndicesFileNameVec.push_back( regionTypeIndicesFileName );
        }
      }    
    }
    
    if ( sessionGrayscaleFileNameVec.size() > 0 )
      {    
        std::cout << "Reading grayscale image..." << std::endl;
        std::cout << sessionGrayscaleFileNameVec[0] << std::endl;
        GrayscaleReaderType::Pointer grayReader = GrayscaleReaderType::New();
          grayReader->SetFileName( sessionGrayscaleFileNameVec[0] );
        try
          {
          grayReader->Update();
          }
        catch ( itk::ExceptionObject &excp )
          {
          std::cerr << "Exception caught reading grayscale image:";
          std::cerr << excp << std::endl;
          }
          
        std::cout << "DONE." << std::endl;    
        grayscaleImageRead = true;    

        assistantInstance->SetGrayscaleImage( grayReader->GetOutput() );	

        LabelMapType::SizeType    size    = assistantInstance->GetGrayscaleImage()->GetBufferedRegion().GetSize();
        LabelMapType::SpacingType spacing = assistantInstance->GetGrayscaleImage()->GetSpacing();
        LabelMapType::PointType   origin  = assistantInstance->GetGrayscaleImage()->GetOrigin();

        //-------
        // Label the main window to indicate which image has been read
        //    
        unsigned int slashLoc = -1;
    
        do
          {
            slashLoc = sessionGrayscaleFileNameVec[0].find( "/", slashLoc+1 );
          }
        while ( sessionGrayscaleFileNameVec[0].find( "/", slashLoc+1 ) != std::string::npos );
     
        acilAssistantMainWindow->label( sessionGrayscaleFileNameVec[0].substr( slashLoc+1, sessionGrayscaleFileNameVec[0].size()-slashLoc-1 ).c_str() );

	//-------
	// Initialize the label maps
	//
        assistantInstance->InitializeLabelMapImage( size, spacing, origin );

	//-------
	// Read in the label map if necessary
	//
	if ( (sessionInLabelMapFileNameVec[0]).compare("NA") != 0 )
	  {
            std::cout << "Reading label map image..." << std::endl;
            LabelMapReaderType::Pointer labelReader = LabelMapReaderType::New();
              labelReader->SetFileName( sessionInLabelMapFileNameVec[0] );
            try
              {
              labelReader->Update();
              }
            catch ( itk::ExceptionObject &excp )
              {
              std::cerr << "Exception caught reading label map file:";
              std::cerr << excp << std::endl;
              }

            std::cout << "DONE." << std::endl;	
            labelMapImageRead = true;
            
            assistantInstance->SetLabelMapImage( labelReader->GetOutput() );
          }
        
        int numberOfSlices = grayReader->GetOutput()->GetBufferedRegion().GetSize()[2];
 
        sliceSlider->maximum( numberOfSlices-1 );        	
       
        InitializeViewer();                
      }
    else
      {
        std::cout << "Session has been completed or session file is empty." << std::endl;
      }
}

void opacitySlider_CB( Fl_Widget*, void* ) {
  UpdateViewer();
}

void paintBrushAndEraserMenu_CB( Fl_Widget*, void* ) {
  paintBrushAndEraserInput->paintBrushAndEraserWindow->show();
}

void leftLungRightLungMenu_CB( Fl_Widget*, void* ) {
  if ( !grayscaleImageRead )
{
  std::cout << "Must first read a grayscale image!" << std::endl;
  
  return;
}

if ( !labelMapImageRead )
{
  std::cout << "Must first read a label map image!" << std::endl;
  
  return;
}

std::cout << "Segmenting left lung and right lung..." << std::endl;
if ( !assistantInstance->LabelLeftLungRightLung() )
{
  std::cout << "Error segmenting left lung and right lung." << std::endl;
  
  return;
}

std::cout << "DONE." << std::endl;

UpdateViewer();
}

void lungMenu_CB( Fl_Widget*, void* ) 
{
  if ( !grayscaleImageRead )
    {
    std::cout << "Must first read a grayscale image!" << std::endl;  
    return;
    }
  
  sliceViewer->iwMax( -100 );
  sliceViewer->iwMin( -1200 );

  UpdateViewer();
}

void muscleMenu_CB( Fl_Widget*, void* ) 
{
  if ( !grayscaleImageRead )
    {
    std::cout << "Must first read a grayscale image!" << std::endl;  
    return;
    }

  sliceViewer->iwMax( 90 );
  sliceViewer->iwMin( -50 );
  
  UpdateViewer();
}

void lungLobesMenu_CB( Fl_Widget*, void* ) {
  if ( !grayscaleImageRead )
{
  std::cout << "Must first read a grayscale image!" << std::endl;
  
  return;
}

if ( !labelMapImageRead )
{
  std::cout << "Must first read a label map image!" << std::endl;
  
  return;
}

std::cout << "Segmenting lung lobes..." << std::endl;
if ( !assistantInstance->SegmentLungLobes() )
{
  std::cout << "Fissures have not been properly identified." << std::endl;
  
  return;
}

std::cout << "DONE." << std::endl;

UpdateViewer();
}

void Quit_CB( Fl_Widget*, void* ) {
  exit(0);
}

void clickSelect_CB( float x, float y, float z, float value ) {
  if ( grayscaleImageRead )
{ 
   ACILAssistantBase::GrayscaleImageType::IndexType index;

  index[0] = static_cast< unsigned int >( x );
  index[1] = static_cast< unsigned int >( y );
  index[2] = static_cast< unsigned int >( z );

  if ( paintBrushAndEraserInput->paintBrushAndEraserWindow->visible() )
    {
      unsigned int  radius           = paintBrushAndEraserInput->GetToolRadius();
      unsigned char cipType          = paintBrushAndEraserInput->GetChestType(); 	
      unsigned char cipRegion        = paintBrushAndEraserInput->GetChestRegion(); 	
      short         lowerThreshold   = paintBrushAndEraserInput->GetToolLowerThreshold();
      short         upperThreshold   = paintBrushAndEraserInput->GetToolUpperThreshold();

      unsigned int orientation = sliceViewer->orientation();

      if ( paintBrushAndEraserInput->GetPaintBrushSelected() )
        {  
        assistantInstance->PaintLabelMapSlice( index, cipType, cipRegion, radius, lowerThreshold, upperThreshold, orientation ); 
        }
      else if ( paintBrushAndEraserInput->GetEraserSelected() )
        {  
        assistantInstance->EraseLabelMapSlice( index, cipRegion, cipType, radius, lowerThreshold, upperThreshold, 
                                               paintBrushAndEraserInput->GetEraseSelectedSelected(), orientation );
        }
   
      UpdateViewer();	
    }
}
}

void SaveLabelMapImageMenu_CB( Fl_Widget*, void* ) {
  if ( !grayscaleImageRead )
{
  std::cerr << "No label map image to save!" << std::endl;
  
  return;
}


Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::CREATE, "Open");	                
    chooser.show();
 
  typedef itk::Image< unsigned short, 3 >       LabelMapType;
  typedef itk::ImageFileWriter< LabelMapType >  WriterType; 

  //-------
  // Block until user picks something
  //
  while(chooser.shown())
    {
    Fl::wait(); 
    }

  if ( chooser.value() == NULL )
    {   
    return; 
    }
  else
    {
    std::cout << "Writing label map image..." << std::endl;
    WriterType::Pointer writer = WriterType::New();
      writer->SetFileName( chooser.value() );
      writer->SetInput( assistantInstance->GetLabelMapImage() );
      writer->UseCompressionOn();
      try
      {
      writer->Update();
      }
      catch ( itk::ExceptionObject &excp )
      {
      std::cerr << "Exception caught writer label map image:";
      std::cerr << excp << std::endl;
      }
        
    std::cout << "DONE." << std::endl;
    }
}

void SaveSessionDataMenu_CB( Fl_Widget*, void* ) 
{
  typedef itk::Image< unsigned short, 3 >             LabelMapType;
  typedef itk::ImageFileWriter< LabelMapType >        WriterType; 
  typedef itk::Image< short, 3 >                      GrayscaleImageType;
  typedef itk::ImageFileReader< LabelMapType >        LabelMapReaderType;
  typedef itk::ImageFileReader< GrayscaleImageType >  GrayscaleReaderType;

  if ( !grayscaleImageRead )
    {
    std::cerr << "Nothing to save!" << std::endl;
    
    return;
    }

  if ( (sessionOutLabelMapFileNameVec[0]).compare( "NA" ) != 0 )
    {
    std::cout << "Writing label map image..." << std::endl;
    WriterType::Pointer writer = WriterType::New();
      writer->SetFileName( sessionOutLabelMapFileNameVec[0] );
      writer->SetInput( assistantInstance->GetLabelMapImage() );
      writer->UseCompressionOn();
    try
      {
      writer->Update();
      }
    catch ( itk::ExceptionObject &excp )
      {
      std::cerr << "Exception caught writer label map image:";
      std::cerr << excp << std::endl;
      }
        
    std::cout << "DONE." << std::endl;
    }
  
  //
  // Write the region and type indices to file
  //
  if ( (sessionRegionTypeIndicesFileNameVec[0]).compare( "NA" ) != 0 )
    {
    std::cout << "Writing region and type indices..." << std::endl;
    assistantInstance->WritePaintedRegionTypePoints( sessionRegionTypeIndicesFileNameVec[0] );
    std::cout << "DONE." << std::endl;
    }

  //
  // Now that the label map has been saved, we want to load the group
  // of images for the next session block. First eliminate the file names
  // of the session block that was just processed
  //
  sessionGrayscaleFileNameVec.erase( sessionGrayscaleFileNameVec.begin() );              
  sessionInLabelMapFileNameVec.erase( sessionInLabelMapFileNameVec.begin() );
  sessionOutLabelMapFileNameVec.erase( sessionOutLabelMapFileNameVec.begin() );
  sessionRegionTypeIndicesFileNameVec.erase( sessionRegionTypeIndicesFileNameVec.begin() );

  //
  // Make sure the memory allocated for the images of the current session
  // block has been freed. Calling this method will also clear the stored
  // type indices that were recorded during painting
  //
  assistantInstance->Clear();

  if ( sessionGrayscaleFileNameVec.size() > 0 )
    {
    //
    // Read the grayscale image
    //
    std::cout << "Reading grayscale image..." << std::endl;
    std::cout << sessionGrayscaleFileNameVec[0] << std::endl;
    GrayscaleReaderType::Pointer grayscaleReader = GrayscaleReaderType::New();
      grayscaleReader->SetFileName( sessionGrayscaleFileNameVec[0] );
    try
      {
      grayscaleReader->Update();
      }
    catch ( itk::ExceptionObject &excp )
      {
      std::cerr << "Exception caught reading grayscale image:";
      std::cerr << excp << std::endl;
      }

    int numberOfSlices = grayscaleReader->GetOutput()->GetBufferedRegion().GetSize()[2];

    sliceSlider->maximum( numberOfSlices-1 );

    assistantInstance->SetGrayscaleImage( grayscaleReader->GetOutput() );
    
    std::cout << "DONE." << std::endl;  	
    
    LabelMapType::SizeType    size    = assistantInstance->GetGrayscaleImage()->GetBufferedRegion().GetSize();
    LabelMapType::SpacingType spacing = assistantInstance->GetGrayscaleImage()->GetSpacing();
    LabelMapType::PointType   origin  = assistantInstance->GetGrayscaleImage()->GetOrigin();

    assistantInstance->InitializeLabelMapImage( size, spacing, origin );

    //
    // Label the main window to indicate which image has been read
    //    
    unsigned int slashLoc = -1;
    
    do
      {
      slashLoc = sessionGrayscaleFileNameVec[0].find( "/", slashLoc+1 );
      }
    while ( sessionGrayscaleFileNameVec[0].find( "/", slashLoc+1 ) != std::string::npos );
    
    acilAssistantMainWindow->label( sessionGrayscaleFileNameVec[0].substr( slashLoc+1, sessionGrayscaleFileNameVec[0].size()-slashLoc-1 ).c_str() );

    //
    // Read the label map image
    //
    if ( (sessionInLabelMapFileNameVec[0]).compare( "NA" ) != 0 )
      {
      std::cout << "Reading label map image..." << std::endl;
      std::cout << sessionInLabelMapFileNameVec[0] << std::endl;
      LabelMapReaderType::Pointer labelMapReader = LabelMapReaderType::New();
        labelMapReader->SetFileName( sessionInLabelMapFileNameVec[0] );
      try
        {
        labelMapReader->Update();
        }
      catch ( itk::ExceptionObject &excp )
        {
        std::cerr << "Exception caught reading label map image:";
        std::cerr << excp << std::endl;
        }

      assistantInstance->SetLabelMapImage( labelMapReader->GetOutput() );
      
      std::cout << "DONE." << std::endl;
      }
    
    //
    // Update the slice viewer with the new images
    //
    sliceViewer->clear();
    InitializeViewer();

    //
    // Make sure the paint brush points to the correct image
    //
    paintBrushAndEraserInput->SetLabelMapImage( assistantInstance->GetLabelMapImage() );
    }
  else
    {
    std::cout << "Session complete." << std::endl;
    }
}

void SaveRegionTypePointsMenu_CB( Fl_Widget*, void* ) 
{
  if ( !grayscaleImageRead )
    {
    std::cerr << "No region-type indices to save!" << std::endl;
    
    return;
    }


  Fl_File_Chooser chooser(".", "*", Fl_File_Chooser::CREATE, "Open");	                
  chooser.show();
 
  //
  // Block until user picks something
  //
  while(chooser.shown())
    {
    Fl::wait(); 
    }
  
  if ( chooser.value() == NULL )
    {   
    return; 
    }
  else
    {
    std::cout << "Writing region-type indices..." << std::endl;
    assistantInstance->WritePaintedRegionTypePoints( chooser.value() );
    std::cout << "DONE." << std::endl;
    }
}
